'''
Attempts to split text into questions and answers rather than breaking it up by speaker.
'''
from typing import List
from openai import OpenAI
import json
from dotenv import load_dotenv
import os
import eng_spacysentiment as sentiment

load_dotenv()
KEY = os.getenv("OPENAI_KEY")

class QAObjects():
    def __init__(self, question, answer):
        self.question = question
        self.answer = answer

    def analyze_sentiment(self, sentiment_analyzer):
        sentiment = sentiment_analyzer(self.get_question_and_answer())
        
        return sentiment
    
    def get_question_and_answer(self):
        return f"{self.question} {self.answer}"
    
    def __str__(self):
        return f"{self.question}\n{self.answer}"

def query_openai(input_file: str, output_file: str, model: str = "gpt-4o-mini") -> dict:
    '''
    Query the OpenAI API to split a conversation into question-answer pairs.

    Args:
        input_file (str): The path to the input file containing the conversation (json or txt file generated by whisperai).
        output_file (str): The path to the output file to write the question-answer pairs to (json file from openai).
        model (str): The OpenAI model to use for the query (open ai model to query).
    '''

    client = OpenAI(api_key=KEY)

    file_type = input_file.split(".")[-1]
    if file_type == "json":
        with open(input_file, "r") as f:
            text = json.load(f)["text"]
    elif file_type == "txt":
        with open(input_file, "r") as f:
            text = f.read()
    else:
        raise ValueError("Input file must be a json or txt file.")
    print(f"text: {text}")

    # Define the prompt
    prompt = (
        "Your task is to take a conversation between a doctor and a patient and split it "
        "into question-answer pairs and label each speaker as either the doctor or patient. "
        "Each question-answer pair should be separated by a '|' "
        "and each pair should be on a new line. For example:"
        "Doctor: What is your name?|Patient: My name is John.\n"
    )

    # Interact with the API
    diarized_text = client.chat.completions.create(
        model=model,
        messages=[
            {"role": "system", "content": prompt},
            {"role": "user", "content": text},
        ]
    )

    response_dict = diarized_text.to_dict()
    with open(output_file, "w") as f:
        json.dump(response_dict, f)

    return response_dict

def create_qa_objects(openai_response: dict) -> List[QAObjects]:
    response = openai_response['choices'][0]['message']['content']
    qa_pairs = response.split("\n")
    QAs = []
    for qa_pair in qa_pairs:
        question, answer = qa_pair.split("|")
        qa_object = QAObjects(question=question, answer=answer)
        QAs.append(qa_object)
    return QAs

def clean_with_openai(input_file: str, output_file: str, model: str = "gpt-4o-mini"):
    client = OpenAI(api_key=KEY)

    file_type = input_file.split(".")[-1]
    if file_type == "json":
        with open(input_file, "r") as f:
            text = json.load(f)["text"]
    elif file_type == "txt":
        with open(input_file, "r") as f:
            text = f.read()
    else:
        raise ValueError("Input file must be a json or txt file.")
    print(f"text: {text}")

    prompt = (
        "Your task is to take a conversation between a doctor and clean up any errors in the text."
    )

    clean_text = client.chat.completions.create(
        model=model,
        messages=[{
            "role": "system",
            "content": prompt
        },
        {
            "role": "user",
            "content": text
        }]
    )

    return clean_text

    
if __name__ == "__main__":
    input_file = "test.json"
    output_file = "output-doc-pat.json"
    sentiment_output_file = "sentiment-doc-pat.txt"
    sentiment_analyzer = sentiment.load()
    
    '''
    doc = sentiment_analyzer("I love you")
    print(doc.cats)
   
    openai_response = query_openai(input_file, output_file)
    
    with open(output_file, "r") as f:
        openai_response = json.load(f)
       
    qas = create_qa_objects(openai_response)
    with open(sentiment_output_file, "w") as f:
        f.write("")

    counts = {
        "positive": 0,
        "negative": 0,
        "neutral": 0
    }
    for qa in qas:
        with open(sentiment_output_file, "a") as f:
            sent = qa.analyze_sentiment(sentiment_analyzer).cats
            f.write(f"{qa.get_question_and_answer()}\n")
            f.write(f"{sent}\n")
            if sent["positive"] >= 0.75:
                counts["positive"] += 1
            elif sent["negative"] >= 0.75:
                counts["negative"] += 1
            else:
                counts["neutral"] += 1
    with open(sentiment_output_file, "a") as f:
        f.write(f"FINAL COUNTS: {counts}\n")
    '''

    clean_text = clean_with_openai(input_file, output_file)
    with open("cleaned_by_chat.txt", "w") as f:
        f.write(clean_text.to_dict()["choices"][0]["message"]["content"])
    
            